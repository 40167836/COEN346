import threading
lock = threading.Lock()
condition = threading.Condition()

def process_run(arr, i, t):
    quantum = arr[0][0]
    with lock:
        while arr[i][1] != 0:
            if quantum <= arr[i][1]:
                arr[i][1] = arr[i][1] - 4
                t += quantum
            else:
                t += arr[i][1]
                arr[i][1] = 0
            #condition.wait()#need to put a notify to wake up the thread somewhere
    return t

def process_select(arr,user, number_of_process):
    processes = []
    for i in range (1,(number_of_process+1)):

        k = (i + user)
        with lock:
            print(str(arr[k][0])+'\n')
        y = threading.Thread(target=process_run, args=(arr,k, time))
        processes.append(y)
        y.start()
        i += (arr[i][1] + 1)  # Skip to the next user
    for t in processes:
        t.join()
    return 0

def user_select(arr):
    i = 1
    users = []
    while i < len(arr):
        print(arr[i][0])
        x = threading.Thread(target= process_select, args=(arr, i, arr[i][1]))
        users.append(x)
        x.start()
        i += (arr[i][1] + 1)  # Skip to the next user

    for t in users:
            t.join()
    return 0

if __name__ == "__main__":
    time= 1
    input_array = []
    open("output.txt", "w").close()

    with open('input.txt', 'r') as file:
        for line in file.readlines():
            input_array.append(line.split())

    # Convert all numbers in the array to integers
    input_array = [[int(word) if word.isdigit() else word for word in val] for val in input_array]

    user_select(input_array)


