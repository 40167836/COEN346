import threading
import time

# Locks for synchronization
process_lock = threading.Lock()
time_lock = threading.Lock()  # Ensures time continuity

time_counter = 1  # Start global time at 1s

# FUNCTION TO READ INPUT
def read_input_file(filename="input.txt"):
    """ Reads input and structures it into a list of dictionaries with process IDs. """
    with open(filename, 'r') as file:
        lines = [line.strip().split() for line in file.readlines()]

    quantum = int(lines[0][0])  # Extract the quantum time (first line)
    processes = []  # List of processes with explicit IDs
    unique_users = set()
    process_id = 0  # Assign explicit process IDs

    i = 1  # Start processing from the second line (index 1)
    while i < len(lines):
        if len(lines[i]) == 2:  # Detect user line (username + num of processes)
            username, num_processes = lines[i][0], int(lines[i][1])
            unique_users.add(username)

            for _ in range(num_processes):
                i += 1  # Move to next line
                ready_time, burst_time = map(int, lines[i])
                processes.append([username, ready_time, burst_time, process_id])  # Include process ID
                process_id += 1  # Increment process ID

        i += 1  # Move to next user

    num_active_users = len(unique_users)
    return num_active_users, quantum, processes

###### FUNCTION TO SIMULATE PROCESS EXECUTION ######
def run_process(user, process_id, execution_time, process):
    """ Simulates the execution of a process, updating burst time. """
    global time_counter

    if execution_time > 0:
        with process_lock:
            print(f"Time {time_counter}s, User {user}, Process {process_id}, Started, Remaining Burst: {process[2]}")
            print(f"Time {time_counter}s, User {user}, Process {process_id}, Resumed, Remaining Burst: {process[2]}")

            time.sleep(execution_time)  # Simulate execution delay

            process[2] -= execution_time  # Reduce burst time

            with time_lock:
                time_counter += execution_time  # Ensure time is updated correctly

            if process[2] <= 0:
                process[2] = 0
                print(f"Time {time_counter}s, User {user}, Process {process_id}, Finished, Remaining Burst: {process[2]}")
            else:
                print(f"Time {time_counter}s, User {user}, Process {process_id}, Paused, Remaining Burst: {process[2]}")

# FUNCTION FOR FAIR-SHARE ROUND ROBIN SCHEDULING #
def fair_share_scheduler(num_active_users, quantum, processes):
    """ Implements Fair-Share Round Robin Scheduling with strict quantum enforcement. """
    global time_counter

    print("\n--- Starting Scheduler ---\n")

    while processes:
        active_users = list(set(p[0] for p in processes))  # Get unique users
        num_active_users = len(active_users)

        if num_active_users == 0:
            break  # Stop if no active users are left

        user_share = quantum // num_active_users  # Divide quantum among users
        executed_any = False  # Track if a process was executed

        userThreads = []  # Store active threads for users
        for user in active_users:
            # Each user will have their own thread for scheduling
            user_thread = threading.Thread(target=process_select, args=(user, processes, user_share, time_counter))
            userThreads.append(user_thread)
            user_thread.start()

        for user_thread in userThreads:
            user_thread.join()  # Ensure all user threads are finished before continuing

        # Remove completed processes
        processes = [p for p in processes if p[2] > 0]

    print("\n--- Scheduler Stopped ---")

def process_select(user, processes, user_share, time_counter):
    """ Function to select and run processes for a particular user """
    processThreads = []  # Threads for processes of the current user

    # Select processes for this user
    user_processes = [p for p in processes if p[0] == user and p[1] <= time_counter]
    num_user_processes = len(user_processes)

    if num_user_processes == 0:
        return  # No processes ready for this user

    process_share = user_share // num_user_processes  # Divide userâ€™s share among processes
    remaining_quantum = process_share  # Available quantum for this user

    for process in user_processes:
        if process[2] == 0:
            continue  # Skip completed processes

        execution_time = min(process[2], remaining_quantum)

        process_thread = threading.Thread(target=run_process, args=(process[0], process[3], execution_time, process))
        processThreads.append(process_thread)
        process_thread.start()


    # Wait for all threads of this user to complete
    for thread in processThreads:
        thread.join()

if __name__ == "__main__":
    # Read and organize input from the file
    num_active_users, quantum, processes = read_input_file()

    # Run Fair-Share Round Robin Scheduler
    fair_share_scheduler(num_active_users, quantum, processes)

